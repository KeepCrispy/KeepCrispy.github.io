<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-08T09:35:46-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Keeping it Crispy</title><subtitle>AreWhyW, software engineer exploring security research</subtitle><author><name>AreWhyW</name></author><entry><title type="html">Using Cipher Block Chaining(CBC cipher) to Encrypt Access Granting Certificates</title><link href="http://localhost:4000/SecureAuthCert" rel="alternate" type="text/html" title="Using Cipher Block Chaining(CBC cipher) to Encrypt Access Granting Certificates" /><published>2023-04-28T00:00:00-07:00</published><updated>2023-04-28T00:00:00-07:00</updated><id>http://localhost:4000/SecureAuthCert</id><content type="html" xml:base="http://localhost:4000/SecureAuthCert">&lt;p&gt;In this project, I wanted to explore the use of a CBC (Cipher Block Chaining) block cipher to generate encrypted certificates with customizable expiry dates. This system creates a primary server authority certificate which is then used to generate additional access certificates. This provides a secure and reliable way of granting access to services and ensuring that the access is only granted for a specified amount of time.&lt;/p&gt;

&lt;p&gt;Access granting certificates are an important part of our digital security and are used to control access to services, websites, and other online resources. They are often used in authentication protocols such as OAuth and Kerberos to help protect against unauthorized access. OAuth and Kerberos both use a centralized authority system to issue and validate certificates, but this project provides the ability to have the expiry of the access certificates built into the certificates themselves.&lt;/p&gt;

&lt;p&gt;CBC (Cipher Block Chaining) is a type of block cipher encryption which uses a random hash to encrypt the data stored in the certificates. This ensures that the data is secure and that each certificate is unique, making it difficult to tamper with. This is an important feature as it helps to protect the data stored in the certificates and helps to ensure that they can only be used for the specified time period.&lt;/p&gt;

&lt;p&gt;Overall, this project provides a secure and reliable way of granting access to services and websites, with the added security of a CBC block cipher and the ability to set expiry dates for each certificate. It is a great way to ensure that access is only granted for a specified amount of time, without relying on a centralized authority system.&lt;/p&gt;

&lt;p&gt;example of certificate generation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/secureauthcert1.png&quot; alt=&quot;SecureAuthCert running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Link to My Github Project - &lt;a href=&quot;https://github.com/KeepCrispy/SecureAuthCert&quot;&gt;SecureAuthCert&lt;/a&gt;&lt;/p&gt;</content><author><name>AreWhyW</name></author><category term="Posts" /><category term="Access Control" /><category term="DevSecOps" /><summary type="html">In this project, I wanted to explore the use of a CBC (Cipher Block Chaining) block cipher to generate encrypted certificates with customizable expiry dates. This system creates a primary server authority certificate which is then used to generate additional access certificates. This provides a secure and reliable way of granting access to services and ensuring that the access is only granted for a specified amount of time.</summary></entry><entry><title type="html">Setting up and running Snort on Ubuntu</title><link href="http://localhost:4000/SnortLab" rel="alternate" type="text/html" title="Setting up and running Snort on Ubuntu" /><published>2023-04-28T00:00:00-07:00</published><updated>2023-04-28T00:00:00-07:00</updated><id>http://localhost:4000/SnortLab</id><content type="html" xml:base="http://localhost:4000/SnortLab">&lt;p&gt;Snort is an intrusion detection and prevention system (IDPS), and can be configured to be used as a Web Application Firewall(WAF). Intrusion detection and prevention systems (IDPS) are used to detect and protect networks from malicious traffic and requests. They are able to detect suspicious activity, such as malicious requests and traffic, and take action to block the malicious activity before it reaches its destination. IDPS systems are an important part of network security, as they can prevent malicious actors from exploiting security vulnerabilities.&lt;/p&gt;

&lt;p&gt;Today, I’m going to share my knowledge on setting up Snort! Snort is a powerful tool for intrusion detection and prevention. I will explain the steps needed to setup Snort on your network and walk you through configuring snort and testing your setup. I’ll also provide helpful tips and tricks that will help you get the most out of Snort.&lt;/p&gt;

&lt;p&gt;First make sure your system is up to date:
sudo apt update
sudo apt upgrade&lt;/p&gt;

&lt;p&gt;To install on Ubuntu use the following command:
sudo apt install snort&lt;/p&gt;

&lt;p&gt;Next we want to configure Ubuntu’s network settings to allow the snort traffic to be monitored&lt;/p&gt;

&lt;p&gt;Edit /etc/sysctl.conf and add the following lines:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;net.ipv4.conf.default.accept_source_route = 0&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.all.accept_source_route = 0&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.default.accept_redirects = 0&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.all.accept_redirects = 0&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.default.send_redirects = 0&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.all.send_redirects = 0&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.default.rp_filter = 1&lt;/li&gt;
  &lt;li&gt;net.ipv4.conf.all.rp_filter = 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rp_filter setting in the sysctl.conf file determines whether or not the kernel will accept reverse path filtering on the network traffic. Reverse path filtering ensures that incoming packets are coming from the same source as the reply packets. This is important for network security, as it helps to prevent malicious packets from entering the network. We want this turned on.&lt;/p&gt;

&lt;p&gt;We want to turn on the rp_filter setting in the sysctl.conf file for snort because it helps to protect against malicious packets entering the network. By enabling reverse path filtering, snort can more accurately detect and respond to malicious activity on the network, as it can detect when incoming packets are not from the same source as the reply packets.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/snort1.png&quot; alt=&quot;systemctl config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next we will need to update the snort config file. This is where we tell snort how to process the traffic, what traffic to look for, and when and how to output alerts.&lt;/p&gt;

&lt;p&gt;Locating the snort config:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/snort2.png&quot; alt=&quot;snort config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Snort config location:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/snort3.png&quot; alt=&quot;snort config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;#config information&lt;/p&gt;

&lt;p&gt;The config files does several things. It tells snort what traffic to scan like the port you want to keep an eye on, what to look for and the rules you want to scan against, and finally how to log/output alerts.&lt;/p&gt;

&lt;p&gt;things it can scan for:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;active scanning&lt;/li&gt;
  &lt;li&gt;shellcode rules&lt;/li&gt;
  &lt;li&gt;suspicious TCP/UDP traffic&lt;/li&gt;
  &lt;li&gt;suspicious connections to your web/ssh/ftp/smb servers or outwards&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a look at it’s basic port conifigurations:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/snort4.png&quot; alt=&quot;snort config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;reading through the config you will come across some preprocessor and decoder configurations as well.&lt;/p&gt;

&lt;p&gt;The Snort decoder and preprocessors are responsible for decoding and processing packets as they are received. The decoder is responsible for breaking down the packets into their individual headers, while the preprocessors perform tasks such as stream reassembly, protocol normalization, and port scanning detection. Together, they allow snort to accurately detect and respond to malicious activity.&lt;/p&gt;

&lt;p&gt;Finally the part that makes snort shine is the output plugin settings. The output plugin allows you to automate piping alerts to your desired file/webapp for logging purposes&lt;/p&gt;

&lt;p&gt;here are a few output formats:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;xml, cvs,unified outputs, and system logs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unified binary output can be used with something like Barnyard for additional features such as JSON support for web api integration&lt;/p&gt;

&lt;p&gt;You can also create a basic CSV using:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;output alert_csv: filename (options seperated by commas)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of these settings can be left as default for now. But, you will want to install PullPork aftwards for the ability to automatically update the community rulesets for instrusion detection.&lt;/p&gt;

&lt;p&gt;Finally, after setting the above up. you will need to be root to access your network interfaces when running Snort.&lt;/p&gt;

&lt;p&gt;use the following command for snort:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sudo snort -i (network interface) -v -c /etc/snort/snort.conf&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/snort5.png&quot; alt=&quot;snort running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Snort outputs alerts in the terminal when it detects suspicious activity on a network. This could be anything from a malicious scan to an attack attempt. The output is a text-based alert that includes information such as the source and destination IP addresses, the protocol used, and any related alert message.&lt;/p&gt;

&lt;p&gt;#Snort as a WAF&lt;/p&gt;

&lt;p&gt;Web application firewalls (WAFs) are used to protect web applications from malicious traffic and requests. They can detect and block malicious traffic and filter out malicious requests, such as those for SQL injection and cross-site scripting attacks. WAFs are becoming increasingly popular as more organizations move their applications and data to the cloud. By using a WAF, organizations can ensure that their applications and data are secure from malicious actors.&lt;/p&gt;

&lt;p&gt;Snort IPS mode stands for Intrusion Prevention System mode. This mode allows Snort to take action when it detects suspicious activity, such as blocking malicious traffic or filtering out malicious requests. It is used to protect networks from malicious actors and prevent the exploitation of security vulnerabilities.&lt;/p&gt;

&lt;p&gt;The IPS mode can be activated when starting Snort using “-Q –daq afpacket” followed by the interfaces arguement “-i eth0:eth1” where eth0 and eth1 are the network interfaces you’d like to join.&lt;/p&gt;

&lt;p&gt;With IPS enabled, you’ll be able to add some simple rules using regular expression to the snort config file to drop harmful traffic&lt;/p&gt;

&lt;p&gt;Example - to block SQL injection rule&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;your_target_server_ip&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;to_server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nocase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;pcre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&amp;lt;&amp;gt;()+,]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Above rule will filter:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;From any Source IP&lt;/li&gt;
  &lt;li&gt;From any source Port&lt;/li&gt;
  &lt;li&gt;Destination IP is your_target_server_ip, you need to change this&lt;/li&gt;
  &lt;li&gt;Destination Port is 80 (HTTP)&lt;/li&gt;
  &lt;li&gt;Content should have value “GET “ – can be changed to “POST”&lt;/li&gt;
  &lt;li&gt;Word “nocase” specifies matching is not case sensitive&lt;/li&gt;
  &lt;li&gt;filter based on Regular expression mentioned in “pcre=”[&apos;&quot;\;:|\&amp;amp;$\%\@\\/&amp;lt;&amp;gt;()+,]” will not allow ‘ “ ; : | &amp;amp;
@ \ / &amp;lt; &amp;gt; ( ) + , characters in request.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are additional resources and documentation for further customizing snort.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.snort.org/documents&quot;&gt;Snort Official Documentation - https://www.snort.org/documents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/shirkdog/pulledpork&quot;&gt;Shirkdog’s PulledPork project - https://github.com/shirkdog/pulledpork&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/firnsy/barnyard2&quot;&gt;firnsy’s Barnyard Spooler for JSON alert outputs - https://github.com/firnsy/barnyard2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>AreWhyW</name></author><category term="Posts" /><category term="Snort" /><category term="IDPS" /><category term="WAF" /><category term="DevSecOps" /><summary type="html">Snort is an intrusion detection and prevention system (IDPS), and can be configured to be used as a Web Application Firewall(WAF). Intrusion detection and prevention systems (IDPS) are used to detect and protect networks from malicious traffic and requests. They are able to detect suspicious activity, such as malicious requests and traffic, and take action to block the malicious activity before it reaches its destination. IDPS systems are an important part of network security, as they can prevent malicious actors from exploiting security vulnerabilities.</summary></entry><entry><title type="html">Powershell AMSI Lab - evading using obfuscation and detection POC</title><link href="http://localhost:4000/AMSIProj" rel="alternate" type="text/html" title="Powershell AMSI Lab - evading using obfuscation and detection POC" /><published>2023-04-21T00:00:00-07:00</published><updated>2023-04-21T00:00:00-07:00</updated><id>http://localhost:4000/AMSIProj</id><content type="html" xml:base="http://localhost:4000/AMSIProj">&lt;p&gt;I’m pretty sure many developers like me have came across their code being flagged by windows defender as a virus or malware strictly because it was just doing its job accessing system functions or making a TCP connection to the network service. Having been frustrated by this many times, I wanted to figure out why my legit working code is being flagged with a false positive, while threat actors are able to bypass this security completely.&lt;/p&gt;

&lt;p&gt;The Anti-Malware Scan Interface (AMSI) is a security technology built into the Windows 10 operating system. This interface serves as an open platform for allowing antivirus software to interact with Windows 10, allowing the antivirus program to detect and respond to malicious code. This helps to protect users from malicious software and provide a safer computing environment. AMSI is an essential tool for antivirus programs, as it allows them to detect and block malicious code more effectively. The interface also allows for more accurate detection of malicious code and provides more detailed information about the threats that are detected. This allows antivirus programs to more effectively protect users from threats, as well as provide a more secure computing experience.&lt;/p&gt;

&lt;p&gt;If you look closely into Anti-Malware Scan Interface (AMSI) evasion vulnerabilities published over the years, extensive work has been put into this. Threat actors have developed several techniques to bypass AMSI detection. These techniques include encrypting the payload and decrypting it in memory inside PowerShell, splitting up the payload scripts and recombining them, and using different PowerShell encoding techniques. Additionally, attackers can embed the payload inside another executable, which will not be caught by AMSI until the executable is executed.&lt;/p&gt;

&lt;p&gt;All these techniques were used by threat actors to bypass AMSI detection and it is important to be aware of them in order to understand how attackers can fly under the radar.&lt;/p&gt;

&lt;p&gt;Panagiotis Chartas, a well known Security Researcher, made a great &lt;a href=&quot;https://www.youtube.com/watch?v=tGFdmAh_lXE&quot;&gt;video guide on obfuscation techniques&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;He also posted a great resource on his github: &lt;a href=&quot;https://github.com/t3l3machus/PowerShell-Obfuscation-Bible&quot;&gt;Powershell Obfuscation Bible&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Based on his findings we know that that AMSI isn’t quite able to catch obfuscated powershell code just yet.&lt;/p&gt;

&lt;p&gt;Even though obfuscated code can easily be identified using definitions profiling. The problem though is much deeper, as anyone with programming experience would know that the same code can be easily redesigned with different nuances.&lt;/p&gt;

&lt;p&gt;The possibilities of obfucation are endless and it’s a recipe for disaster.&lt;/p&gt;

&lt;p&gt;Panagiotis findings into this vulnerability means that, at present, it can be exploited using very simple obscuration with basic string manipulation, all without the need of external tools.&lt;/p&gt;

&lt;p&gt;If a threat actor took advantage of this, their powershell scripts will easily fly under the radar.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Remediation Strategies&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In order to mitigate the threat of malicious code bypassing AMSI detection, it is important to perform security audits on APIs being used, harden your network infrastructure, and make sure your systems are properly configured with good access control. Additionally, it is important to regularly update antivirus software and perform regular security audits and patching of the system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pentesting Screenshots&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here is a simple POC of an obfuscated shell encapsulated in an exe runtime that was generated using an obfuscator tool. It is being used to gain remote access in a custom lab. This was done with antivirus scans turned on.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/launchpsx_amsi1.png&quot; alt=&quot;psx running custom payload&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and what the reverse shell looks like once launched.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/customps_amsi1.png&quot; alt=&quot;reverse&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;My thoughts on remdiation strategies&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Obfuscation techniques include randomizing variable names, padding with more logic and inserting wrapper logic around the executed scripts. Because of the small file size requirement for most payloads to fly undetected when logged, it is likely that the core execution steps are unchanged to keep things compact. Thus even if the variable lengths changes, the logical pattern of function calls, and assigning variable values are likely unchanged when additional information is padded on. Making it somewhat possible to flag by scanning the program for execution logic patterns.&lt;/p&gt;

&lt;p&gt;I’ve wrote a simple opensource &lt;a href=&quot;https://github.com/KeepCrispy/BlueWyvern&quot;&gt;POC BlueWyvern Scanner&lt;/a&gt; to use Regex to catch obfuscated and some possibly malicious code that would require some deeper knowledge of yara to perform.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Best Practices for Users&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In order to protect their systems from malicious code, users should follow best practices such as using strong passwords, avoiding suspicious links and downloads, and regularly checking server and operating system access logs. Additionally, users should be aware of the latest threats and tricks attackers use to bypass security measures.&lt;/p&gt;

&lt;p&gt;It is always good practice to be engaging in DevSecOps to ensure the deployment pipeline and environments are monitored for integrity.&lt;/p&gt;

&lt;p&gt;Checking server and operating system access logs is a good way to determine if there has been any malicious activity on the system. However, it is important to note that depending on the type of malware used, it may be difficult to detect the malicious activity in the logs.&lt;/p&gt;

&lt;p&gt;It is always best to take preventative measures. This can include regularly auditing and patching the system. Making sure to regularly review access control measures. Additionally, it is important to ensure that users are following best practices when it comes to online security, such as using strong passwords and avoiding suspicious links and downloads.&lt;/p&gt;</content><author><name>AreWhyW</name></author><category term="Posts" /><category term="AMSI" /><category term="Powershell" /><summary type="html">I’m pretty sure many developers like me have came across their code being flagged by windows defender as a virus or malware strictly because it was just doing its job accessing system functions or making a TCP connection to the network service. Having been frustrated by this many times, I wanted to figure out why my legit working code is being flagged with a false positive, while threat actors are able to bypass this security completely.</summary></entry></feed>