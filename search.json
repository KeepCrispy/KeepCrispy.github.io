[
  
    {

      "title"    : "Setting up and running Snort on Ubuntu",
      "url"      : "/SnortLab",
      "content"  : "Snort can be considered an EDR (Endpoint Detection and Response) system. An EDR system is a type of security monitoring system that is used to detect and respond to malicious activity on a network. Snort uses a combination of rules and signatures to detect malicious behavior, and can be used to alert system administrators of suspicious activity.\n\nToday, I’m going to share my knowledge on setting up Snort! Snort is a powerful tool for intrusion detection and prevention. I will explain the steps needed to setup Snort on your network and walk you through configuring snort and testing your setup. I’ll also provide helpful tips and tricks that will help you get the most out of Snort.\n\nFirst make sure your system is up to date:\nsudo apt update\nsudo apt upgrade\n\nTo install on Ubuntu use the following command:\nsudo apt install snort\n\nNext we want to configure Ubuntu’s network settings to allow the snort traffic to be monitored\n\nEdit /etc/sysctl.conf and add the following lines:\n\n\n  net.ipv4.conf.default.accept_source_route = 0\n  net.ipv4.conf.all.accept_source_route = 0\n  net.ipv4.conf.default.accept_redirects = 0\n  net.ipv4.conf.all.accept_redirects = 0\n  net.ipv4.conf.default.send_redirects = 0\n  net.ipv4.conf.all.send_redirects = 0\n  net.ipv4.conf.default.rp_filter = 1\n  net.ipv4.conf.all.rp_filter = 1\n\n\nThe rp_filter setting in the sysctl.conf file determines whether or not the kernel will accept reverse path filtering on the network traffic. Reverse path filtering ensures that incoming packets are coming from the same source as the reply packets. This is important for network security, as it helps to prevent malicious packets from entering the network. We want this turned on.\n\nWe want to turn on the rp_filter setting in the sysctl.conf file for snort because it helps to protect against malicious packets entering the network. By enabling reverse path filtering, snort can more accurately detect and respond to malicious activity on the network, as it can detect when incoming packets are not from the same source as the reply packets.\n\n\n\nNext we will need to update the snort config file. This is where we tell snort how to process the traffic, what traffic to look for, and when and how to output alerts.\n\nLocating the snort config:\n\n\n\nSnort config location:\n\n\n\n#config information\n\nThe config files does several things. It tells snort what traffic to scan like the port you want to keep an eye on, what to look for and the rules you want to scan against, and finally how to log/output alerts.\n\nthings it can scan for:\n\n  active scanning\n  shellcode rules\n  suspicious TCP/UDP traffic\n  suspicious connections to your web/ssh/ftp/smb servers or outwards\n\n\nHere is a look at it’s basic port conifigurations:\n\n\n\nreading through the config you will come across some preprocessor and decoder configurations as well.\n\nThe Snort decoder and preprocessors are responsible for decoding and processing packets as they are received. The decoder is responsible for breaking down the packets into their individual headers, while the preprocessors perform tasks such as stream reassembly, protocol normalization, and port scanning detection. Together, they allow snort to accurately detect and respond to malicious activity.\n\nFinally the part that makes snort shine is the output plugin settings. The output plugin allows you to automate piping alerts to your desired file/webapp for logging purposes\n\nhere are a few output formats:\n\n  xml, cvs,unified outputs, and system logs\n\n\nUnified binary output can be used with something like Barnyard for additional features such as JSON support for web api integration\n\nYou can also create a basic CSV using:\n\n  output alert_csv: filename (options seperated by commas)\n\n\nMost of these settings can be left as default for now. But, you will want to install PullPork aftwards for the ability to automatically update the community rulesets for instrusion detection.\n\nFinally, after setting the above up. you will need to be root to access your network interfaces when running Snort.\n\nuse the following command for snort:\n\n  sudo snort -i (network interface) -v -c /etc/snort/snort.conf\n\n\n\n\nSnort outputs alerts in the terminal when it detects suspicious activity on a network. This could be anything from a malicious scan to an attack attempt. The output is a text-based alert that includes information such as the source and destination IP addresses, the protocol used, and any related alert message.\n\nHere are additional resources and documentation for further customizing snort.\n\n  Snort Official Documentation - https://www.snort.org/documents\n  Shirkdog’s PulledPork project - https://github.com/shirkdog/pulledpork\n  firnsy’s Barnyard Spooler for JSON alert outputs - https://github.com/firnsy/barnyard2"

    },
  
    {

      "title"    : "Powershell AMSI Lab - evading using obfuscation and detection POC",
      "url"      : "/AMSIProj",
      "content"  : "I’m pretty sure many developers like me have came across their code being flagged by windows defender as a virus or malware strictly because it was just doing its job accessing system functions or making a TCP connection to the network service. Having been frustrated by this many times, I wanted to figure out why my legit working code is being flagged with a false positive, while threat actors are able to bypass this security completely.\n\nThe Anti-Malware Scan Interface (AMSI) is a security technology built into the Windows 10 operating system. This interface serves as an open platform for allowing antivirus software to interact with Windows 10, allowing the antivirus program to detect and respond to malicious code. This helps to protect users from malicious software and provide a safer computing environment. AMSI is an essential tool for antivirus programs, as it allows them to detect and block malicious code more effectively. The interface also allows for more accurate detection of malicious code and provides more detailed information about the threats that are detected. This allows antivirus programs to more effectively protect users from threats, as well as provide a more secure computing experience.\n\nIf you look closely into Anti-Malware Scan Interface (AMSI) evasion vulnerabilities published over the years, extensive work has been put into this. For example, I have looked into and tried to replicate some of these findings such as trying to encrypt the payload and decrypting them in memory inside PowerShell. I have also looked into splitting up the payload scripts and recombining them, which has been patched by Microsoft to prevent this attack vector. I have also looked into different PowerShell encoding techniques using open source tools. I also tried embedding the payload inside another executable, and found that the AMSI will no longer be able to catch the embedded code from being copied. However in memory, it will still flag it when executed.\n\nAll these techniques were used by threat actors to bypass AMSI detection and it is important to be aware of them in order to understand attack vectors.\n\nLeoX Aka ProxyBlade wrote a great detailed write-up on his findings for AMSI detection and his trial and error process. link to his write-up\n\nPanagiotis Chartas also made a great video guide on obfuscation techniques\n\nBased on their findings and testing for different encryptions, seems that AMSI now scans for the code’s content for anything suspicious before it is executed.\n\nLeoX also made a great POC called EvilRat for his writeup and it does the job to test for this vulnerability.\n\nSome could argue that it’s just some obfuscated code and can easily be identified using definitions profiling. The problem though is much deeper, as any developer would know the same code can be designed with different flavours, some more efficient than others. Than there’s the problem that a complex shell can be made out of many different variables, and logic can always be obfuscated with purposely placed bad code design.\n\nSo what happens when you obfuscate the code so much so that it’s unrecognizable? What if you have variables of varying lengths, comprised of numbers, underscore and alphabets?\n\nWhat if your shell script execution order, and variable names are always changing? What if you employ alternate function calls to your methods? or add replace random error catchers?\n\nIt’s a recipe for disaster and the possibilities for exploiting this is almost limitless.\n\nLeoX and Panagiotis discovered a gaping vulnerability that at present can be exploited using very simple obscuration without the need of heavy lifting Red Team tools.\n\nOn top of that, it makes it super easy to implement a randomized file obscurator using basic programming string manipulation.\n\nIf a threat actor took advantage of this, their powershell scripts will easily fly under the radar. This means, until this is patched, it’s crucial to harden your network infrastructure and make sure it’s properly configured with good access control.\n\nHere is a simple POC of an obfuscated shell encapsulated in an exe runtime that was generated using an obfuscator tool. It is being used to gain remote access in a custom lab.\n\n\n\nand what the reverse shell looks like once launched.\n\n\n\nFinal thoughts on remdiation strategies\n\nObfuscation techniques include randomizing variable names, padding with more logic and inserting wrapper logic around the executed scripts. Because of the small file size requirement for most payloads to fly undetected when logged, it is likely that the core execution steps are unchanged to keep things compact. Thus even if the variable lengths changes, the logical pattern of function calls, and assigning variable values are likely unchanged when additional information is padded on. Making it somewhat trivial to flag by scanning the program for execution logic patterns.\n\nI’ve wrote a simple POC Linear-Content-Scanner to test this idea. Feel free to rift off the idea, though I would recommend using a more robust DevSecOps solution.\n\nIt is always good practice to be engaging in DevSecOps to ensure the deployment pipeline and environments are monitored for integrity.\n\nChecking server and operating system access logs is a good way to determine if there has been any malicious activity on the system. However, it is important to note that depending on the type of malware used, it may be difficult to detect the malicious activity in the logs.\n\nIt is always best to take preventative measures. This can include regularly auditing and patching the system. Making sure to regularly review access control measures. Additionally, it is important to ensure that users are following best practices when it comes to online security, such as using strong passwords and avoiding suspicious links and downloads."

    },
  

  

  
]